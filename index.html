<!DOCTYPE HTML>
<html>
  <head>
    <style>
      body {
        margin: 0px;
        padding: 0px;
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas" width="578" height="200"></canvas>
    <script>
      var canvas = document.getElementById('myCanvas');
      var context = canvas.getContext('2d');
	  canvas.width = window.innerWidth;
	  canvas.height = window.innerHeight;

  var drawKey = function(ctx) {
    ctx.beginPath();
	ctx.arc(-15,0,5,0,2*Math.PI);
    ctx.moveTo(-10,0);
	ctx.lineTo(15,0);
	ctx.lineTo(15,-10);
    ctx.moveTo(10,-5);
    ctx.lineTo(10,0);
    ctx.lineWidth = 3;
	ctx.stroke();
    ctx.closePath();
  }

  var rectTestPattern = function(ctx, width, height) {
    drawKey(ctx);
    ctx.beginPath();
    ctx.rect(-width/2,-height/2,width,height);
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  var triangle1TestPattern = function(ctx, length) {

    var midLength = Math.sqrt(Math.pow(length/2,2)+Math.pow(length/4,2));
    var shortOffset = midLength*Math.sin(Math.PI/8);
    var longOffset = midLength*Math.cos(Math.PI/8);
	
    drawKey(ctx);

    ctx.beginPath();
    ctx.moveTo(shortOffset,-longOffset);
    ctx.lineTo(shortOffset,-longOffset+length);
    ctx.lineTo(shortOffset-length,-longOffset+length);
    ctx.lineTo(shortOffset,-longOffset);
	ctx.lineWidth = 1;
    ctx.stroke();
    ctx.closePath();
  }

  var rectGrid = function(ctx, width, height, patternAngle, patternFunction) {
    ctx.translate(canvas.width/2,canvas.height/2);
	ctx.rotate(patternAngle*Math.PI/180);

	var widthPad=canvas.height*(Math.abs(Math.sin(patternAngle*Math.PI/180)));
	var heightPad=canvas.width*(Math.abs(Math.sin(patternAngle*Math.PI/180)));

	for (var y=-canvas.height-heightPad-height/2; y<=canvas.height+heightPad+height/2; y+=height) {
   	  for (var x=-canvas.width-widthPad-width/2; x<=canvas.width+widthPad+width/2; x+=width) {
		patternFunction(x,y);
      }
    }
    ctx.translate(-canvas.width/2,-canvas.height/2);
  }

  var obliqueGrid = function(ctx, width, height, patternAngle, skewAngle, patternFunction) {
    ctx.translate(canvas.width/2,canvas.height/2);
	ctx.rotate(patternAngle*Math.PI/180);

	var widthPad=canvas.height*(Math.abs(Math.sin(patternAngle*Math.PI/180)));
	var heightPad=canvas.width*(Math.abs(Math.sin(patternAngle*Math.PI/180)));

	var xOffset=height*Math.tan(skewAngle*Math.PI/180);
    var heightCounter=0;

	for (var y=-canvas.height-heightPad-height/2; y<=canvas.height+heightPad+height/2; y+=height) {
   	  for (var x=-canvas.width-widthPad-width/2-Math.ceil(height*Math.tan(skewAngle))*(width-xOffset); x<=canvas.width+widthPad+width/2+Math.ceil(height*Math.tan(skewAngle))*xOffset; x+=width) {
		patternFunction(x,y);
      }
    }
    ctx.translate(-canvas.width/2,-canvas.height/2);
  }

  // Group 1
  var p1 = function(ctx, width, height, patternAngle, skewAngle=0, skew=true) {
	if (skewAngle < -90 || skewAngle > 90) { throw "The pattern angle must be between -45 and 45 degress." }
    obliqueGrid(ctx, width, height, patternAngle, skewAngle, function(x,y) {
		
		var xOffset=height*Math.tan(skewAngle*Math.PI/180)/4;

		// Draw original
	    ctx.translate(x+xOffset,y);
		if (skew) { ctx.transform(1,0,Math.tan(skewAngle*Math.PI/180),1,0,0); }
	    rectTestPattern(ctx,width,height);
		if (skew) { ctx.transform(1,0,-Math.tan(skewAngle*Math.PI/180),1,0,0); }
		ctx.translate(-(x+xOffset),-y);
    });
  }

  // Group 2
  var p2 = function(ctx, width, height, patternAngle, skewAngle=0, skew=true) {
	if (skewAngle < -90 || skewAngle > 90) { throw "The pattern angle must be between -45 and 45 degress." }
    obliqueGrid(ctx, width, height, patternAngle, skewAngle, function(x,y) {
		
		// Calculate the offset values
		var xOffset=height*Math.tan(skewAngle*Math.PI/180)/4;
        var yOffset=width/4;

		//window.alert(xOffset);

		// Draw original
        ctx.translate(x-xOffset,y-yOffset);
		if (skew) { ctx.transform(1,0,Math.tan(skewAngle*Math.PI/180),1,0,0); }
	    rectTestPattern(ctx,width,height/2);
		if (skew) { ctx.transform(1,0,-Math.tan(skewAngle*Math.PI/180),1,0,0); }
		ctx.translate(-(x-xOffset),-(y-yOffset));

	    // Draw rotated image	
		ctx.translate(x+xOffset,y+yOffset);
		if (skew) { ctx.transform(1,0,Math.tan(skewAngle*Math.PI/180),1,0,0); }
        ctx.scale(-1,-1);
	    rectTestPattern(ctx,width,height/2);
        ctx.scale(-1,-1);
		if (skew) { ctx.transform(1,0,-Math.tan(skewAngle*Math.PI/180),1,0,0); }
		ctx.translate(-(x+xOffset),-(y+yOffset));
    });
  }	

  // Group 3
  var pm = function(ctx, width, height, patternAngle) {
    rectGrid(ctx, width, height, patternAngle, function(x,y) {

		// Calculate the offset values
        var yOffset=height/4;

		// Draw original 
 		ctx.translate(x,y-yOffset);
	    rectTestPattern(ctx,width,height/2);
		ctx.translate(-x,-(y-yOffset));

		// Draw mirror image
		ctx.translate(x,y+yOffset);
        ctx.scale(1,-1);
	    rectTestPattern(ctx,width,height/2);
        ctx.scale(1,-1);
		ctx.translate(-x,-(y+yOffset));
    });
  }

  // Group 4
  var pg = function(ctx, width, height, patternAngle) {
    rectGrid(ctx, width, height, patternAngle, function(x,y) {

		// Calculate the offset values
        var xOffset=width/4;

		// Draw original 
 		ctx.translate(x-xOffset,y);
	    rectTestPattern(ctx,width/2,height);
		ctx.translate(-(x-xOffset),-y);

		// Draw mirror image
		ctx.translate(x+xOffset,y);
        ctx.scale(1,-1);
	    rectTestPattern(ctx,width/2,height);
        ctx.scale(1,-1);
		ctx.translate(-(x+xOffset),-y);
    });
  }

  // Group 5
  var pmm = function(ctx, width, height, patternAngle) {
    rectGrid(ctx, width, height, patternAngle, function(x,y) {

		// Calculate the offset values
        var xOffset=width/4;
        var yOffset=height/4;

		// Draw original (bottom left) 
 		ctx.translate(x-xOffset,y+yOffset);
	    rectTestPattern(ctx,width/2,height/2);
		ctx.translate(-(x-xOffset),-(y+yOffset));

		// Draw mirror image (top left)
		ctx.translate(x-xOffset,y-yOffset);
        ctx.scale(1,-1);
	    rectTestPattern(ctx,width/2,height/2);
        ctx.scale(1,-1);
		ctx.translate(-(x-xOffset),-(y-yOffset));
	
        // (top right)	
        ctx.translate(x+xOffset,y-yOffset);
        ctx.scale(-1,-1);
	    rectTestPattern(ctx,width/2,height/2);
        ctx.scale(-1,-1);
		ctx.translate(-(x+xOffset),-(y-yOffset));

        // (bottom right)
		ctx.translate(x+xOffset,y+yOffset);
        ctx.scale(-1,1);
	    rectTestPattern(ctx,width/2,height/2);
        ctx.scale(-1,1);
		ctx.translate(-(x+xOffset),-(y+yOffset));
    });
  }

  // Group 6
  var pmg = function(ctx, width, height, patternAngle) {
    rectGrid(ctx, width, height, patternAngle, function(x,y) {

		// Calculate the offset values
        var xOffset=width/4;
        var yOffset=height/4;

		// Draw original (bottom left) 
 		ctx.translate(x-xOffset,y+yOffset);
	    rectTestPattern(ctx,width/2,height/2);
		ctx.translate(-(x-xOffset),-(y+yOffset));

		// Draw mirror image (top left)
		ctx.translate(x-xOffset,y-yOffset);
        ctx.scale(1,-1);
	    rectTestPattern(ctx,width/2,height/2);
        ctx.scale(1,-1);
		ctx.translate(-(x-xOffset),-(y-yOffset));
	
        // (top right)	
        ctx.translate(x+xOffset,y-yOffset);
        ctx.scale(-1,1);
	    rectTestPattern(ctx,width/2,height/2);
        ctx.scale(-1,1);
		ctx.translate(-(x+xOffset),-(y-yOffset));

        // (bottom right)
		ctx.translate(x+xOffset,y+yOffset);
        ctx.scale(-1,-1);
	    rectTestPattern(ctx,width/2,height/2);
        ctx.scale(-1,-1);
		ctx.translate(-(x+xOffset),-(y+yOffset));
    });
  }

  // Group 6
  var p4 = function(ctx, length, patternAngle) {
    rectGrid(ctx, length, length, patternAngle, function(x,y) {

		// Calculate the offset values
        var offset=length/4;

		// Draw original (bottom left) 
 		ctx.translate(x-offset,y+offset);
	    rectTestPattern(ctx,length/2,length/2);
		ctx.translate(-(x-offset),-(y+offset));

		// Draw mirror image (top left)
		ctx.translate(x-offset,y-offset);
        ctx.rotate(Math.PI/2);
	    rectTestPattern(ctx,length/2,length/2);
        ctx.rotate(3*Math.PI/2);
		ctx.translate(-(x-offset),-(y-offset));
	
        // (top right)	
        ctx.translate(x+offset,y-offset);
        ctx.rotate(Math.PI);
	    rectTestPattern(ctx,length/2,length/2);
        ctx.rotate(Math.PI);
		ctx.translate(-(x+offset),-(y-offset));

        // (bottom right)
		ctx.translate(x+offset,y+offset);
        ctx.rotate(3*Math.PI/2);
	    rectTestPattern(ctx,length/2,length/2);
        ctx.rotate(Math.PI/2);
		ctx.translate(-(x+offset),-(y+offset));
    });
  }

  var p4m = function(ctx, length, patternAngle) {
    rectGrid(ctx, length, length, patternAngle, function(x,y) {

        //x = canvas.width/2;
        //y = canvas.height/2;

        var midLength = Math.sqrt(Math.pow(length/2,2)+Math.pow(length/4,2));
        var shortOffset = midLength*Math.sin(Math.PI/8)/2;
        var longOffset = midLength*Math.cos(Math.PI/8)/2;

		// Draw original (bottom left bottom) 
 		ctx.translate(x-shortOffset,y+longOffset);
	    triangle1TestPattern(ctx,length/2);
		ctx.translate(-(x-shortOffset),-(y+longOffset));
		
        // (bottom left top) 
 		ctx.translate(x-longOffset,y+shortOffset);
        ctx.rotate(3*Math.PI/2);
        ctx.scale(1,-1);
	    triangle1TestPattern(ctx,length/2);
        ctx.scale(1,-1);
        ctx.rotate(Math.PI/2);
		ctx.translate(-(x-longOffset),-(y+shortOffset));

        // (top left bottom) 
 		ctx.translate(x-longOffset,y-shortOffset);
        ctx.rotate(Math.PI/2);
	    triangle1TestPattern(ctx,length/2);
        ctx.rotate(3*Math.PI/2);
		ctx.translate(-(x-longOffset),-(y-shortOffset));
        
        // (top left top) 
 		ctx.translate(x-shortOffset,y-longOffset);
        ctx.rotate(Math.PI);
        ctx.scale(-1,1);
	    triangle1TestPattern(ctx,length/2);
        ctx.scale(-1,1);
        ctx.rotate(Math.PI);
		ctx.translate(-(x-shortOffset),-(y-longOffset));
        
        // (top right top) 
 		ctx.translate(x+shortOffset,y-longOffset);
        ctx.rotate(Math.PI);
	    triangle1TestPattern(ctx,length/2);
        ctx.rotate(Math.PI);
		ctx.translate(-(x+shortOffset),-(y-longOffset));

        // (top right bottom) 
 		ctx.translate(x+longOffset,y-shortOffset);
        ctx.rotate(Math.PI/2);
        ctx.scale(1,-1);
	    triangle1TestPattern(ctx,length/2);
        ctx.scale(1,-1);
        ctx.rotate(3*Math.PI/2);
		ctx.translate(-(x+longOffset),-(y-shortOffset));
		
        // (top left top) 
 		ctx.translate(x+longOffset,y+shortOffset);
        ctx.rotate(3*Math.PI/2);
	    triangle1TestPattern(ctx,length/2);
        ctx.rotate(Math.PI/2);
		ctx.translate(-(x+longOffset),-(y+shortOffset));
	
    	// (top left bottom) 
 		ctx.translate(x+shortOffset,y+longOffset);
        ctx.scale(-1,1);
	    triangle1TestPattern(ctx,length/2);
        ctx.scale(-1,1);
		ctx.translate(-(x+shortOffset),-(y+longOffset));
    });
  }

  p4m(context,50,45);

    </script>
  </body>
</html>
